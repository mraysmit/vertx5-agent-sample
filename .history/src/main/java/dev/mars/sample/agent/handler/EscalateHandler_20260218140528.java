package dev.mars.sample.agent.handler;

import dev.mars.sample.agent.processor.FailureHandler;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

/**
 * {@link FailureHandler} that escalates a trade failure which is recognised but
 * cannot be automatically repaired â€” for example, an invalid counterparty.
 *
 * <h2>Side effects</h2>
 * Publishes a {@code TradeEscalated} event to {@link EventBusAddresses#EVENTS_OUT}
 * containing the trade ID and the original failure reason.
 *
 * <h2>Example result</h2>
 * <pre>
 * {
 *   "type":    "TradeEscalated",
 *   "tradeId": "T-100",
 *   "by":      "deterministic-processor",
 *   "reason":  "Invalid Counterparty"
 * }
 * </pre>
 *
 * @see FailureHandler
 */
public class EscalateHandler implements FailureHandler {

  private final Vertx vertx;
  private final String eventsAddress;

  /**
   * @param vertx         the Vert.x instance for event bus access
   * @param eventsAddress the event bus address to publish escalation events to
   */
  public EscalateHandler(Vertx vertx, String eventsAddress) {
    this.vertx = vertx;
    this.eventsAddress = eventsAddress;
  }

  @Override
  public Future<JsonObject> handle(JsonObject event) {
    String tradeId = event.getString("tradeId");
    String reason = event.getString("reason");

    JsonObject escalated = new JsonObject()
      .put("type", "TradeEscalated")
      .put("tradeId", tradeId)
      .put("by", "deterministic-processor")
      .put("reason", reason);

    vertx.eventBus().publish(eventsAddress, escalated);

    return Future.succeededFuture(escalated);
  }
}
